/**
 * Copyright (c) 2011 Cloudsmith Inc. and other contributors, as listed below.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *   Cloudsmith
 * 
 */

/* 
 * Grammar for Puppet pp
 * ---
 * This grammar is for the puppet .pp (puppet manifest) language.
 * The grammar is less restrictive than the actual language and deferrs much of the validation
 * to the model validation step. This has the advantage that more specific error messages can be
 * produced and gives an opportunity to provide quick fixes for common problems. It also means that
 * while editing, a valid substructure may be recognized by the parser even if placed in the wrong
 * context - this makes it easier to understand and fix what is wrong.
 * The more lenient grammar is a LL(*) with backtracking grammar where all expressions are placed in
 * an order of precedence. Typically, no distinction is made between left/right value expressions.
 */ 
grammar org.cloudsmith.geppetto.pp.dsl.PP
import "platform:/resource/org.cloudsmith.geppetto.pp/model/PP.ecore" as pp

// enables use of ecore types
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// Important note about white space and comments:
// ------
// OWS stands for Optional White Space and includes white space and comments
// Only the starting PuppetManifest rule should eat leading OWS, all other rules should
// consume trailing white space. This allows all rules to start with a 'significant token'.
// (If not done this way, the parser will see *many* alternatives all starting with OWS).
// 
// Most 'intermediate' rules do not have to care about this - only the rules that consume a token
// must deal with trailing OWS.
// The Manifest allows leading space(s) and comments to be included in the model in an OWSOBJ (to aid in generating
// a meaningsful header).
//

// Important note about 'unused' object creating rules
// ---
// Some object creating rules may appear to be unused but are in fact used in callbacks from the validator.
// These callbacks should obtain the rules via the generated grammar access class to ensure that rule removal
// does not go unnoticed (there will be compile time errors).
// (Unused *data* rules are ignored by the parser generator).
// 

PuppetManifest returns pp::PuppetManifest
	: {pp::PuppetManifest}
		leadingSpaceAndComments = OWSOBJ?
		(statements += ExpressionList)*
	;
	
// -- EXPRESSION
// (Refers to the expression with the lowest precedence)
// Should be used by expressions that allow a single Expression
Expression returns pp::Expression : RelationshipExpression ;

// --EXPRESSION LIST
// Should be used by expressions that allow a sequence of expressions (as such
// a sequence can include non-parenthesized function calls (which are detected after
// parsing)
ExpressionList returns pp::Expression : 
	RelationshipExpression ({pp::ExprList.expressions += current} COMMA OWS
		expressions += RelationshipExpression (COMMA OWS
			expressions += RelationshipExpression)*)?
		;
		
// LOWEST PRECEDENCE
//  left  relationship
//  left  assignment
//  left  OR
//  left  AND
//  left  Relational: GREATEREQUAL GREATERTHAN LESSTHAN LESSEQUAL
//  left  Equality: NOTEQUAL ISEQUAL
//  left  Shift: LSHIFT RSHIFT
//  left  Additive: MINUS PLUS
//  left  Multiplicative: TIMES DIV
//  left  Matching: IN MATCH NOMATCH
//  nonassoc UMINUS
//  right NOT
//  'primary'
// HIGHEST


// Relationship
// Note that RelationshipExpression has lowest precedence since it has an operator
// '<-' that otherwise clashes with LT UnaryMinus
//
// VALIDATION checks that left and right are one of: 
// - ResourceExpression (but not a ResourceOverride, or virtual resource)
// - ResourceReference
// - CollectExpression
EdgeOperator:  INEDGE | OUTEDGE | INEDGE_SUB | OUTEDGE_SUB ;
RelationshipExpression returns pp::Expression
	: ResourceExpression 
		({pp::RelationshipExpression.leftExpr = current}
		opName = EdgeOperator OWS
		rightExpr = ResourceExpression)* 
  	;
  	
// -- ResourceExpression 
// handles:
// - resource definition 'name {'
// - defaults for resource definitions  'Name {'
// - resource overrides 'expr [exprlist] {'
// - virtual and exported resources @name {, and @@name {
// The parser makes no distinction between these and allows nested expresions compatible with all three
// VALIDATION checks:
// - if resourceClass != CLASS_REF, then ResourceBodies must have a name
// - if resourceClass == CLASS_REF or AtExpression, 
//		then only one ResourceBody is allowed, and ResourceBody can not have a name
// - if resourceExpr = AtExpression the ResourceBody's attribute list may contain additions, otherwise not			
//
ResourceExpression returns pp::Expression
	: AssignmentExpression 
		({pp::ResourceExpression.resourceExpr = current}
			LBRACE OWS 
				(resourceData += ResourceBody 
					(SEMI OWS resourceData += ResourceBody)*
					(SEMI OWS)?
				)?
			RBRACE OWS
		)?
		;

// Note: allows all AttributeOperation subtypes but this depends on the parent's type
// VALIDATION checks allowed types	
ResourceBody returns pp::ResourceBody
	:  nameExpr = Expression OWS COLON OWS attributes = AttributeOperations?
	|  attributes = AttributeOperations
	;

AttributeDefinition returns pp::AttributeDefinition
	: key = NAME OWS FARROW OWS value = Expression 
	;

AttributeAddition returns pp::AttributeAddition
	: key = NAME OWS PARROW OWS value = Expression
	;

AttributeOperation returns pp::AttributeOperation
	: AttributeDefinition
	| AttributeAddition
	;
	
AttributeOperations returns pp::AttributeOperations
	: attributes += AttributeOperation (COMMA OWS attributes += AttributeOperation)* endComma?
	;

// NOTE: This construct is required due to an Xtext bug, it would be preferred to state (COMMA OWS)? directly
// in rules using endComma as this makes formatting work ok. The construct below will hide the OWS and
// formatting needs to be aware of the OWS in an endComma.
endComma : COMMA OWS;

// VALIDATION checks leftExpr must be AT or Variable
AssignmentExpression returns pp::Expression
	: AppendExpression ({pp::AssignmentExpression.leftExpr = current}
		EQ OWS 
		rightExpr = AppendExpression
	  )? 
  	;

// VALIDATION checks leftExpr must be Variable (does not seem to allow append to at - e.g. a[1] +=)
AppendExpression returns pp::Expression
	: OrExpression 
		({pp::AppendExpression.leftExpr = current}
		PLUSEQ OWS
		rightExpr = OrExpression
	  )? 
  	;

OrExpression returns pp::Expression:
	AndExpression ({pp::OrExpression.leftExpr = current}
		KW_OR OWS 
		rightExpr = AndExpression
	 )*
	;
	
AndExpression returns pp::Expression:
	RelationalExpression ({pp::AndExpression.leftExpr=current}
		KW_AND OWS 
		rightExpr = RelationalExpression
	 )*
	;

RelationalOperator : GTEQ | LTEQ | GT | LT ;
RelationalExpression returns pp::Expression:
	EqualityExpression ({pp::RelationalExpression.leftExpr=current} 
		opName = RelationalOperator OWS
		rightExpr = EqualityExpression
	)*
	;
	
EqualityOperator : EQ2 | NOTEQ ;
EqualityExpression returns pp::Expression:
	ShiftExpression ({pp::EqualityExpression.leftExpr=current}
		opName = EqualityOperator OWS
		rightExpr = ShiftExpression
	)*
	;

ShiftOperator : LSHIFT | RSHIFT ;
ShiftExpression returns pp::Expression:
	AdditiveExpression ({pp::ShiftExpression.leftExpr=current}
		opName=ShiftOperator OWS 
		rightExpr=AdditiveExpression
	)*
	;
	
AdditiveOperator : PLUS | MINUS ;	
AdditiveExpression returns pp::Expression:
	MultiplicativeExpression ({pp::AdditiveExpression.leftExpr=current} 
		opName = AdditiveOperator OWS
		rightExpr = MultiplicativeExpression
	)*
	;

// Note: '%' not supported by Puppet
MultiplicativeOperator : ASTERISK | SLASH ;
MultiplicativeExpression returns pp::Expression:
	MatchingExpression ({pp::MultiplicativeExpression.leftExpr=current} 
		opName = MultiplicativeOperator OWS
		rightExpr = MatchingExpression
	)*
	;

// Note: MatchingExpression is special - regexp can only be a RHS
// VALIDATION checks regex rhs
MatchingOperator : MATCH | NOTMATCH ;
MatchingExpression returns pp::Expression:
	InExpression ({pp::MatchingExpression.leftExpr=current}
		opName = MatchingOperator OWS
		rightExpr = LiteralRegex
	)*
	;

InExpression returns pp::Expression:
	UnaryOrHigherExpression ({pp::InExpression.leftExpr=current}
		opName = KW_IN OWS
		rightExpr = UnaryOrHigherExpression
	)*
	;
	
UnaryOrHigherExpression returns pp::Expression
	: UnaryMinusExpression
	| NotExpression
	| InfixExpression
	;
	
UnaryMinusExpression returns pp::UnaryMinusExpression
	: MINUS OWS expr = InfixExpression
	;
	
NotExpression returns pp::UnaryNotExpression
	: EXCLAMATION OWS expr = InfixExpression
	;


// Note: AtExpression serves dual purpose: ResourceReference and hash access
// VALIDATION: checks 2 level nesting constraint on At a[x][y] is ok but not a[x][y][z]
// VALIDATION: checks At dual roles and validates accordingly (only single parameter for normal At) etc.	
// TODO: Rename the Rule, it should be called AtExpression (there are no other infix operators here...)
InfixExpression  returns pp::Expression:
	CollectExpression ({pp::AtExpression.leftExpr=current}
		LBRACK OWS 
			(parameters += Expression (COMMA OWS parameters += Expression)*)?
		RBRACK OWS
	)*
	;


// TODO: VALIDATE that CollectExpression classReference is a ClassReference
CollectExpression  returns pp::Expression:
	SelectorExpression ({pp::CollectExpression.classReference = current}
		query = CollectQuery
		(LBRACE OWS 
			(attributes = AttributeOperations)?
		RBRACE OWS)?
	)?
	;

// VALIDATION ensures that query only contains:
//  - ('and' | 'or' | VariableExpression | LiteralName | '==' | '!=' | ParentesisesExpression )	
CollectQuery returns pp::ICollectQuery
	: VirtualCollectQuery
	| ExportedCollectQuery
	;
		
VirtualCollectQuery returns pp::ICollectQuery
	: {pp::VirtualCollectQuery} LCOLLECT  OWS (expr = Expression)? RCOLLECT OWS
	;
	
ExportedCollectQuery returns pp::ICollectQuery
	: {pp::ExportedCollectQuery} LLCOLLECT  OWS (expr = Expression)? RRCOLLECT OWS
	;
	
SelectorExpression returns pp::Expression
	: FunctionCall ({pp::SelectorExpression.leftExpr = current}
		 QUESTION OWS
			( (LBRACE OWS
				parameters += SelectorEntry 
				(COMMA OWS parameters += SelectorEntry)* endComma? 
			   RBRACE OWS)
			   | parameters += SelectorEntry
			)
		)?
	;

// TODO: VALIDATION  rightExpr is not null and both have resonable type
SelectorEntry returns pp::Expression
	: Expression ({pp::SelectorEntry.leftExpr = current} FARROW OWS rightExpr = Expression)?
	;

// FunctionCall has different syntax restrictions depending on context
// - when used where only one expression can occur, parantheses are required around the arguments
// To solve this, the parser does NOT recognize func x as a function call, this is instead treated as
// a sequence of two expressions, a later step will need to determine if 'func' is a function, if so, how
// many arguments it is supposed to take, and then validate if the input is correct.
//
// TODO VALIDATE : functionExpr is a valid function name	
FunctionCall returns pp::Expression 
	: PrimaryExpression ({pp::FunctionCall.leftExpr = current}
		LPAREN OWS 
			(parameters+=Expression (COMMA OWS parameters += Expression)*)?
		RPAREN OWS)?
	;

PrimaryExpression returns pp::Expression
	: IfExpression
	| CaseExpression
	| ImportExpression
	| Definition
	| HostClassDefinition
	| NodeDefinition
	| VirtualNameOrReference
	| LiteralExpression
	| VariableExpression
	| ParenthisedExpression
	;
	
NodeDefinition returns pp::NodeDefinition
	: KW_NODE OWS
		hostNames += HostReference (COMMA OWS hostNames += HostReference)*
		(KW_INHERITS OWS parentName = HostReference)?	
		LBRACE OWS 
			(statements += ExpressionList)* 
		RBRACE OWS
	;

HostReference returns pp::Expression
	: StringExpression
	| LiteralRegex
	| LiteralDefault
	| LiteralNameOrReference
	;
	
HostClassDefinition returns pp::HostClassDefinition
	: KW_CLASS OWS 
		className = UNION_NAME_OR_REFERENCE OWS 
		arguments = DefinitionArgumentList?
		(KW_INHERITS OWS parent = ParentName)?	
		LBRACE OWS 
			statements += ExpressionList* 
		RBRACE OWS 
	;
	
ParentName returns pp::LiteralExpression
	: LiteralDefault
	| LiteralNameOrReference
	;
	
Definition returns pp::Definition
	: KW_DEFINE OWS 
		className = UNION_NAME_OR_REFERENCE OWS
		arguments = DefinitionArgumentList?
		LBRACE OWS
			(statements += ExpressionList)* 
		RBRACE OWS 
	;
		
DefinitionArgumentList returns pp::DefinitionArgumentList
	: {pp::DefinitionArgumentList}
		LPAREN OWS
			(arguments += DefinitionArgument (COMMA OWS arguments += DefinitionArgument)*)?
	  	RPAREN OWS
	;
	
// VALIDATION: Depracted warning if name does not start with $
// VALIDATION: Not all variations of SimplefiedVariableOrName are valid (with NS)
// VALIDATION: value expr is RVALUE
// 	
DefinitionArgument returns pp::DefinitionArgument
	: argName = UNION_VARIABLE_OR_NAME OWS (EQ OWS value = Expression)?
	;

//-- CASE
//
CaseExpression returns pp::CaseExpression
	: KW_CASE OWS switchExpr = Expression 
		LBRACE OWS cases += Case* 
		RBRACE OWS
	;

Case returns pp::Case
	: values += Expression (COMMA OWS values += Expression)* COLON OWS
		LBRACE OWS 
			(statements += ExpressionList)* 
		RBRACE OWS 
	;

//-- IF 
//
// TODO: VALIDATE that the elseStatement is an Else of Elsif, and validate that Else or Elsif
// only appears as parented by If, Else or Elseif
IfExpression returns pp::IfExpression
	: KW_IF OWS 
		condExpr = Expression 
		LBRACE OWS 
			(thenStatements += ExpressionList)*
		RBRACE OWS
			// requires left factoring of 'else' 'elseif'
			( =>KW_ELS 
				( (KW_IF OWS elseStatement = ElseIfExpression) 
				| (KW_E OWS elseStatement = ElseExpression)
				)
			)?
	;

// Note: KW_ELS and KW_E are *only* to get (KW_ pattern based) coloring right for 
// left-factored 'else' 'elsif' keywords
KW_ELS : LOWER_E LOWER_L LOWER_S ;
KW_E : LOWER_E ;
	
ElseExpression returns pp::Expression
	:  {pp::ElseExpression} 
		LBRACE OWS
			(statements += ExpressionList)*
		RBRACE OWS
	;
	
ElseIfExpression returns pp::Expression
	: 	{pp::ElseIfExpression}
		condExpr = Expression 
		LBRACE OWS
			(thenStatements += ExpressionList)*
		RBRACE OWS
			// requires left factoring of 'else' 'elseif'
			(=>KW_ELS (
			(KW_IF OWS elseStatement = ElseIfExpression) | (KW_E OWS elseStatement = ElseExpression)))?
	;

LiteralExpression returns pp::Expression
	: LiteralBoolean
	| LiteralUndef
	| LiteralDefault
	| LiteralList
	| LiteralHash
  	| LiteralRegex
  	| StringExpression
  	| LiteralNameOrReference
	;
		
LiteralNameOrReference returns pp::LiteralNameOrReference
	: value = UNION_NAME_OR_REFERENCE OWS
	;
	
UNION_VARIABLE_OR_NAME :
	DOLLAR? UNION_NAME_OR_REFERENCE
	;
	
UNION_NAME_OR_REFERENCE :
	NS? EXT_WORD_CHAR_NUM+ (NS EXT_WORD_CHAR_NUM+)*
	;
	
ParenthisedExpression returns pp::ParenthesisedExpression
	: LPAREN OWS expr = Expression RPAREN OWS
	;

VirtualNameOrReference returns pp::VirtualNameOrReference 
	: AT exported = ATBoolean? OWS value = UNION_NAME_OR_REFERENCE OWS
	;

// Kludge for a serialization issue using exported = AT?
// Note: has value converter
ATBoolean returns ecore::EBoolean : AT ;

// TODO: No interpolation takes place in DoubleQuotedStrings, there should probably be a warning about that
// TODO: Validate that import has at least one thing to import	
ImportExpression returns pp::ImportExpression
	: {pp::ImportExpression} KW_IMPORT OWS (values += QuotedString (COMMA OWS values += QuotedString)*)?
	;

LiteralList returns pp::LiteralList
	: {pp::LiteralList}
		LBRACK OWS 
			(elements += Expression (COMMA OWS elements += Expression)*)? endComma?
		RBRACK OWS
	;

LiteralHash returns pp::LiteralHash
	: {pp::LiteralHash}
		LBRACE OWS 
			(elements += HashEntry (COMMA OWS elements += HashEntry)* )? endComma?
		RBRACE OWS
	;

// Use LiteralNameOrString to get different literals (to preserve quotes) as opposed to just the token value.
// TODO: Check constraints on LiteralNameOrString is ${name::name} allowed ?
HashEntry returns pp::HashEntry
	: key = LiteralNameOrString FARROW OWS value = Expression
	;

// TODO: Check constraints on LiteralNameOrString is ${name::name} allowed ?
LiteralNameOrString returns pp::Expression
	: StringExpression
	| LiteralName
	;
	
// ResourceRef - has same syntax as n[i] in one special case and depends on context.
// Implemented as n[i,i,i] for At instead and validation will need to catch illegal use
//
	
// KEYWORDS
// Due to backtrackLexer bug, it is not possible to treat keywords as keywords in the grammar directly
// Instead, each keyword must have a rule name that starts with KW_ as this is used to provide syntax
// highlighting. 

KW_CASE		: LOWER_C LOWER_A LOWER_S LOWER_E ;
KW_CLASS 	: LOWER_C LOWER_L LOWER_A LOWER_S LOWER_S ;
KW_DEFAULT	: LOWER_D LOWER_E LOWER_F LOWER_A LOWER_U LOWER_L LOWER_T;
KW_DEFINE	: LOWER_D LOWER_E LOWER_F LOWER_I LOWER_N LOWER_E;
KW_IMPORT 	: LOWER_I LOWER_M LOWER_P LOWER_O LOWER_R LOWER_T;
KW_IF 		: LOWER_I LOWER_F ;

// Note that because of backtracking and complexity, the parsing of ELSE and ELSIF are
// broken up into ELS.. E and ELS.. IF (See IfExpression).
//KW_ELSE 	: LOWER_E LOWER_L LOWER_S LOWER_E ;
//KW_ELSIF	: LOWER_E LOWER_L LOWER_S LOWER_I | LOWER_F;

KW_INHERITS	: LOWER_I LOWER_N LOWER_H LOWER_E LOWER_R LOWER_I LOWER_T LOWER_S;
KW_NODE		: LOWER_N LOWER_O LOWER_D LOWER_E;

// These keywords have special processing in the lexer to ensure that they are not recognized as
// keywords if followed by a 'name char' - i.e. the text 'andy' and 'land' returns individual tokens.
// This special processing is needed for these keywords as they appear as binary operators.
KW_AND 		: 'and' ;
KW_OR 		: 'or';
KW_IN		: 'in' ;
NKW_IN		: 'in' ;
NKW_OR		: 'or' ;
NKW_AND		: 'and' ;

//NKW_IN 		: LOWER_I LOWER_N;
KW_UNDEF	: LOWER_U LOWER_N LOWER_D LOWER_E LOWER_F ;

CONST_TRUE	: LOWER_T LOWER_R LOWER_U LOWER_E ;
CONST_FALSE	: LOWER_F LOWER_A LOWER_L LOWER_S LOWER_E;

// has converter
BooleanValue returns ecore::EBoolean: CONST_TRUE | CONST_FALSE ;

LiteralBoolean 	returns pp::LiteralBoolean
	: value = BooleanValue OWS
	;

LiteralDefault 	returns pp::LiteralDefault
	: {pp::LiteralDefault} KW_DEFAULT OWS
	;
	
LiteralUndef 	returns pp::LiteralUndef
	: {pp::LiteralUndef} KW_UNDEF OWS 
	;

StringExpression returns pp::Expression
	: SingleQuotedString
	| UnquotedString
	| DoubleQuotedString
	;
	
QuotedString returns pp::IQuotedString
	: DoubleQuotedString
	| SingleQuotedString
	;
	
SingleQuotedString returns pp::SingleQuotedString : {pp::SingleQuotedString}
	text = SQ_TEXT OWS
	;

// Special declarations to aid syntax coloring of these terminals	
DQT_QUOTE : QUOTE ;
DQT_DOLLAR : DOLLAR ;

// Double quoted string with expression interpolation
// handles:
// - $ <non variable char or {> is a verbatim $ included in the string
// - $varname - evaluated and included in the string
// - ${ expression } - evaluated and included in the string
//
DoubleQuotedString returns pp::DoubleQuotedString : 
	DQT_QUOTE textExpression = TextExpression DQT_QUOTE OWS
	;

// Lowest precedence 
TextExpression returns pp::TextExpression: 
	DollarTextExpression
	;
	
DollarTextExpression returns pp::TextExpression: 
	VariableTextExpression (
		{pp::VerbatimTE.leading=current} 
		text = DQT_DOLLAR 
		trailing=TextExpression?
	)*
	;
	
VariableTextExpression returns pp::TextExpression: 
	ExpressionTextExpression (
		{pp::VariableTE.leading=current} 
		varName = DOLLAR_VARIABLE 
		trailing = TextExpression?
	)*
	;
	
ExpressionTextExpression returns pp::TextExpression:
	StringPart (
		{pp::ExpressionTE.leading=current}
		DOLLAR LBRACE expression = Expression RBRACE
		trailing = TextExpression?
	)*
	;
		
StringPart returns pp::TextExpression : 
	{pp::VerbatimTE} text = DQT_CHARS? ;

UnquotedString returns pp::Expression 
	: {pp::UnquotedString} DOLLAR LBRACE OWS  expression = Expression RBRACE OWS
	;

// Has data conversion that strips leading/trailing single quotes
SQ_TEXT returns ecore::EString :
	APOSTROPHE singleStringCharacters? APOSTROPHE
	;
	
DQT_CHARS
	: DQ_CHAR
	  DQ_CHAR*
	;
	
// Puppet Double Quoted String Character
DQ_CHAR
	: SOURCE_CHARACTER_EXCEPT__SP_PUNCTUATION // letters and digits
	| WS_CHAR // normal space
	| PUNCTUATION_EXCEPT__BSLASH_QUOTE_DOLLAR // all punctuation exception noted
	| BSLASH SOURCE_CHARACTER
	// escapeSequence // escape sequences
	;		

// Puppet Single Quoted String character 
SQ_CHAR
	: SOURCE_CHARACTER_EXCEPT__SP_PUNCTUATION // letters and digits
	| WS_CHAR // normal space
	| PUNCTUATION_EXCEPT__BSLASH_APOSTROPHE // all punctuation exception noted
	| BSLASH SOURCE_CHARACTER 
	// escapeSequence // escape sequences
	;
	
singleStringCharacters:
	SQ_CHAR (SQ_CHAR)*
	;
		
escapeSequence
	: characterEscapeSequence
// Puppet does not have more advanced understanding/parsing of these:	
//	| octalEscapeSequence
//	| hexEscapeSequence
//	| unicodeEscapeSequence
//	| controlEscapeSequence
//	| metaEscapeSequence
	;
	
characterEscapeSequence
	: singleEscapeCharacter
	| nonEscapeCharacter
	;

// supported single escapes	for puppet
singleEscapeCharacter
	: APOSTROPHE | QUOTE 
	| BSLASH 
	| DOLLAR
//	| LOWER_A | LOWER_B | LOWER_E | LOWER_F // Ruby has these, but not puppet
	| LOWER_N 
//	| LOWER_R  // Ruby has this, but not puppet
	| LOWER_S 
	| LOWER_T 
//	| LOWER_V // Ruby has this, but not puppet
	| NL
	;
	
nonEscapeCharacter:
	SOURCE_CHARACTER_EXCEPT__ESCAPES
	;

//// TODO: If puppet supports ruby String \M-\C-x meta control escape
//metaEscapeSequence
//	: UPPER_M MINUS SOURCE_CHARACTER_EXCEPT_LINE_TERMINATOR
////	| UPPER_M MINUS (UPPER_C MINUS)? sourceCharacter
//	;
//	
//controlEscapeSequence
//	: LOWER_C SOURCE_CHARACTER_EXCEPT_LINE_TERMINATOR
//	| UPPER_C MINUS SOURCE_CHARACTER_EXCEPT_LINE_TERMINATOR 
//	;
//	
//octalEscapeSequence
//	: OCT OCT OCT
//	;
//	
//hexEscapeSequence
//	: LOWER_X HEX HEX
//	;
//	
//unicodeEscapeSequence
//	: LOWER_U HEX HEX HEX HEX
//	;
	
//LiteralNumber
//	: LiteralFloat 
//	| LiteralHexInt
//	| LiteralOctInt
//	| LiteralInt
//	// TODO: Does puppet allow ruby binary 0b010101 ?
//	;
//	
//LiteralFloat : value = decimalLiteral ;
//LiteralInt : value = integerLiteral ;
//LiteralHexInt : value = hexIntegerLiteral ;
//LiteralOctInt : value = octalIntegerLiteral ;
//
//decimalLiteral
//	: decimalIntegerLiteral decimalIntegerLiteralTail
//	| DOT decimalDigits (exponentPart)?
//	;
//
//decimalIntegerLiteralTail
//	: DOT (decimalDigits)? (exponentPart)?
//	| exponentPart
//	;
//
//decimalIntegerLiteral
//	: ZERO
//	| DECIMAL_NON_ZERO (decimalDigits)?
//	;
//
//decimalDigits
//	: (decimalDigit)+
//	;
//
//decimalDigit
//	: DEC
//	;
//	
//exponentPart
//	: EXPONENT_INDICATOR signedInteger
//	;
//
//signedInteger
//	: decimalDigits
//	| PLUS decimalDigits
//	| MINUS decimalDigits
//	;
//
//hexIntegerLiteral
//	: ZERO (LOWER_X | UPPER_X) (HEX)+
//	;
//		
//// TODO: Does puppet allow 0O 0o to denote start of octal (as in ruby)?
//octalIntegerLiteral
//	: ZERO OCT OCT OCT
//	;
//
//integerLiteral
//	: ZERO
//	| DECIMAL_NON_ZERO DEC*
//	;
	
LiteralRegex returns pp::LiteralRegex
	:  value = REGULAR_EXPRESION OWS
	;

REGULAR_EXPRESION
	: SLASH regularExpressionBody SLASH regularExpressionFlags
	;

regularExpressionBody
	: regularExpressionFirstChar regularExpressionChar*
	;

regularExpressionFirstChar
	: SOURCE_CHARACTER_EXCEPT__LINE_TERMINATOR_ASTERISK_SLASH_BSLASH // not * or \ or /
	| backslashSequence
	;

regularExpressionChar
	: (SOURCE_CHARACTER_EXCEPT__LINE_TERMINATOR_ASTERISK_SLASH_BSLASH | ASTERISK) // not \ or /
	| backslashSequence
	;

backslashSequence:
	BSLASH SOURCE_CHARACTER_EXCEPT_LINE_TERMINATOR
	;

regularExpressionFlags:
	// RUBY REGEX flags: i o x m u e s n (optional, or in any order, but only use each once
	// TODO: Don't know if puppet supports these
	(LOWER_I | LOWER_X | LOWER_M | LOWER_U | LOWER_E | LOWER_S | LOWER_N)*
	;


//// CLASS AND VARIABLE NAMES
//className
//	: KW_CLASS
//	| CLASS_NAME
//	| NAME
//	;

LiteralName returns pp::LiteralName
	: value = NAME OWS
	; 

// NOTE: included as it ensures that code is generated that can be used from external code	
LiteralClassName returns pp::LiteralNameOrReference 
	: value = CLASS_NAME OWS 
	;
	  
// NOTE: included as it ensures that code is generated that can be used from external code	
LiteralClassRef returns pp::LiteralNameOrReference 
	: value = CLASS_REF OWS
	;
	 
VariableExpression returns pp::VariableExpression
	: varName = DOLLAR_VARIABLE OWS
	; 
	
NAME : (DEC | LOWER_ALPHA_CHAR) EXT_WORD_CHAR* ;
CLASS_NAME : (LOWER_ALPHA_CHAR EXT_WORD_CHAR*)? (NS LOWER_ALPHA_CHAR EXT_WORD_CHAR*)+;
CLASS_REF: (NS? UPPER_ALPHA_CHAR EXT_WORD_CHAR*)+ ;

DOLLAR_VARIABLE: DOLLAR VARIABLE;
VARIABLE: (WORD_CHAR+ NS)* WORD_CHAR+ ;

EXT_WORD_CHAR : WORD_CHAR | MINUS ;
EXT_WORD_CHAR_NUM : WORD_CHAR | MINUS | DOT; // to allow decimals 0.0E-2 as a name, hex is already ok 0x0aef
WORD_CHAR : (DEC | ALPHA_CHARACTER | UNDERSCORE);

//--CHARACTER CLASSES
//

// characters allowed in source file
SOURCE_CHARACTER
	: SOURCE_CHARACTER_EXCEPT__SP_PUNCTUATION
	| PUNCTUATION
	| WS_CHAR
	;

SOURCE_CHARACTER_EXCEPT__LINE_TERMINATOR_ASTERISK_SLASH_BSLASH
	: SOURCE_CHARACTER_EXCEPT__ASTERISK_SLASH_BSLASH_WS
	| SP
	;
	
SOURCE_CHARACTER_EXCEPT_LINE_TERMINATOR
	: SOURCE_CHARACTER_EXCEPT__SP_PUNCTUATION
	| PUNCTUATION
	| SP 
	;
		
SOURCE_CHARACTER_EXCEPT__SP_PUNCTUATION
	: ANY_DIGIT
	| ANY_LETTER
	;
	
SOURCE_CHARACTER_EXCEPT__ASTERISK
	: SOURCE_CHARACTER_EXCEPT__ASTERISK_SLASH
	| SLASH
	;
	
SOURCE_CHARACTER_EXCEPT__SLASH
	: SOURCE_CHARACTER_EXCEPT__ASTERISK_SLASH
	| ASTERISK
	;

SOURCE_CHARACTER_EXCEPT__ASTERISK_SLASH
	: SOURCE_CHARACTER_EXCEPT__ASTERISK_SLASH_BSLASH_WS
	| BSLASH
	| WS_CHAR
	;
	
// everything except slash, bslash and asterisk			
SOURCE_CHARACTER_EXCEPT__ASTERISK_SLASH_BSLASH_WS
	: ANY_DIGIT
	| ANY_LETTER
	| COMMON_PUNCTUATION
	| CARET
	| DOLLAR
	| DOT
	| PLUS
	| QUESTION
	| LPAREN
	| RPAREN
	| LBRACK
	| RBRACK
	| LBRACE
	| RBRACE
	| PIPE
	| QUOTE
	| APOSTROPHE
	;

// An attempt of ruby-like parsing of strings (unfinished)	
//SOURCE_CHARACTER_EXCEPT__ESCAPES
//	: DIGIT_EIGHT_NINE // 0-7 are using in octal escape
//	| UNICODE_DIGIT // all special digits
//	// all lower case except abcefnrstuv
//	| LOWER_D  
//	| LOWER_G | LOWER_H | LOWER_I | LOWER_J | LOWER_K | LOWER_L | LOWER_M
//	| LOWER_O | LOWER_P | LOWER_Q 
//	| LOWER_W | LOWER_X | LOWER_Y | LOWER_Z
//	| NKW_IN | NKW_AND | NKW_OR
//	// all upper case except CM
//	| UPPER_A | UPPER_B | UPPER_D | UPPER_E | UPPER_F | UPPER_X | UPPER_ALPHA_CHAR_EXT
//	| UNICODE_LETTER
//	| PUNCTUATION_EXCEPT__ESCAPES // no "'\
//	| SP
//	;

SOURCE_CHARACTER_EXCEPT__ESCAPES
	: DEC // Digits 0-9 (must be changed if supporting octal or hex escapes)
	| UNICODE_DIGIT // all special digits
	// all lower case except nst
	| LOWER_A | LOWER_B | LOWER_C | LOWER_D | LOWER_E | LOWER_F
	| LOWER_G | LOWER_H | LOWER_I | LOWER_J | LOWER_K | LOWER_L 
	| LOWER_M
	| LOWER_O | LOWER_P | LOWER_Q
	| LOWER_R // NOTE: pp does not have a \r escape
	| LOWER_U | LOWER_V | LOWER_W | LOWER_X | LOWER_Y | LOWER_Z
	| NKW_IN | NKW_AND | NKW_OR // NOTE: due to special kw handling
	// all upper case (NOTE: if ruby \C \M are added, this must change)
	| UPPER_ALPHA_CHAR
	| UNICODE_LETTER
	| PUNCTUATION_EXCEPT__ESCAPES // no "'\
	| SP 
//	| TAB  | NBSP // now included in SP
	| CR // i.e. WS_CHAR except NL
	;
		
// These terminals may be considered for inclusion in source	
// UNICODE_CONNECTOR_PUNCTUATION
// UNICODE_NONSPACING_MARK
// USP // unicode space
// UNICODE_COMBINING_MARK
// LS // line separator
// PS // paragraph separator

// All digits as one terminal (Note: must change if parsing decimal, octal and hex)	
terminal DEC	: ('0'..'9') ;

//DEC	: ZERO | DECIMAL_NON_ZERO
//	;
	
//DECIMAL_NON_ZERO
//	: DIGIT_ONE_TO_SEVEN | DIGIT_EIGHT_NINE
//	;
		
//OCT	: ZERO | OCTAL_NON_ZERO
//	;
//
//OCTAL_NON_ZERO
//	: DIGIT_ONE_TO_SEVEN
//	;
	
ANY_DIGIT
	: DEC 
//	ZERO | DIGIT_ONE_TO_SEVEN | DIGIT_EIGHT_NINE
	| UNICODE_DIGIT
	;
	
// Any letter (including all unicode letters western, arabic, hebrew)	
ANY_LETTER 
	: ALPHA_CHARACTER
	| UNICODE_LETTER
	;
	
//EXPONENT_INDICATOR
//	:	LOWER_E | UPPER_E
//	;
//
//CONTROL_ESCAPE_CHAR
//	:	LOWER_F | LOWER_N | LOWER_R | LOWER_T | LOWER_V ; 

ALPHA_CHARACTER
	: LOWER_ALPHA_CHAR | UPPER_ALPHA_CHAR;

LOWER_ALPHA_CHAR 
	: LOWER_ATOZ 
	;
	
//UPPER_ALPHA_CHAR 
//	: UPPER_ATOF | UPPER_M | UPPER_X
//	| UPPER_ALPHA_CHAR_EXT 
//	;

//LOWER_ATOF 
//	: LOWER_A | LOWER_B | LOWER_C | LOWER_D | LOWER_E | LOWER_F
//	;
	
LOWER_ATOZ 
	: LOWER_A | LOWER_B | LOWER_C | LOWER_D | LOWER_E | LOWER_F 
	| LOWER_G | LOWER_H | LOWER_I | LOWER_J | LOWER_K | LOWER_L | LOWER_M
	| LOWER_N | LOWER_O | LOWER_P | LOWER_Q | LOWER_R | LOWER_S | LOWER_T | LOWER_U | LOWER_V
	| LOWER_W | LOWER_X | LOWER_Y | LOWER_Z | NKW_IN | NKW_AND | NKW_OR
	;
	
//UPPER_ATOF 
//	: UPPER_A | UPPER_B | UPPER_C | UPPER_D | UPPER_E | UPPER_F
//	;

//HEX : LOWER_ATOF | UPPER_ATOF | DEC
//	;
	
//space hidden() : SP;

PUNCTUATION 
	: COMMON_PUNCTUATION
	| PATTERN_PUNCTUATION
	| ESCAPED_PUNCTUATION
	;
	
ESCAPED_PUNCTUATION 
	: QUOTE		
	| APOSTROPHE	
	| BSLASH
	| DOLLAR		
	;

PUNCTUATION_EXCEPT__BSLASH_QUOTE_DOLLAR_LBRACE
	: COMMON_PUNCTUATION
	| PATTERN_PUNCTUATION_COMMON // w.o LBRACE
	| APOSTROPHE
	;
	 	
PUNCTUATION_EXCEPT__BSLASH_QUOTE_DOLLAR
	: PUNCTUATION_COMMON_AND_PATTERN
	| APOSTROPHE
	;
	
PUNCTUATION_EXCEPT__BSLASH_APOSTROPHE
	: PUNCTUATION_COMMON_AND_PATTERN
	| QUOTE
	| DOLLAR
	;
	
PUNCTUATION_EXCEPT__ESCAPES
	: PUNCTUATION_COMMON_AND_PATTERN
	;
		
PUNCTUATION_COMMON_AND_PATTERN
	: COMMON_PUNCTUATION
	| PATTERN_PUNCTUATION
	;
		
PATTERN_PUNCTUATION
	: PATTERN_PUNCTUATION_COMMON
	| LBRACE
	;
			
PATTERN_PUNCTUATION_COMMON
	: CARET
	| SLASH
	| DOT
	| ASTERISK
	| PLUS
	| QUESTION
	| LPAREN
	| RPAREN
	| LBRACK
	| RBRACK
	| RBRACE
	| PIPE
	;
	
COMMON_PUNCTUATION
	: EXCLAMATION
	| HASH		
	| PERCENT	
	| AMPER		
	| COMMA		
	| MINUS		
	| COLON		
	| SEMI		
	| LT			
	| EQ			
	| GT			
	| AT			
	| UNDERSCORE	
	| GRAVE		
	| TILDE		
	;

//OPERATORS
//	: LTEQ 		 
//	| GTEQ 		 
//	| EQ2			 
//	| NOTEQ		 
//	| LSHIFT		 
//	| RSHIFT		 
//	| AMPER2		 
//	| PIPE2		 
//	| PLUSEQ		 
//	| MINUSEQ		 
//	| TIMESEQ		 
//	| PERCENTEQ	 
//	| LSHIFTEQ	 
//	| RSHIFTEQ	 
//	| AMPEREQ		 
//	| PIPEEQ		 
//	| CARETEQ		 
//	| DIVIDEEQ
//	| MATCH
//	| NOTMATCH
//	| LLCOLLECT 
//	| LCOLLECT
//	| INEDGE
//	| OUTEDGE
//	| INEDGE_SUB
//	| OUTEDGE_SUB
//	| RRCOLLECT
//	| RCOLLECT
//	| FARROW
//	| PARROW
//	// UNUSED in this grammar:
//	// PLUS2	
//	// MINUS2	
//	// EQ3		
//	// NOTEQ2	
//	// GT3		
//	// GT3EQ	
//	;
	
LTEQ 		: LT EQ ; 		// '<='
GTEQ 		: GT EQ ; 		// '>='
EQ2			: EQ EQ ; 		// '=='
NOTEQ		: EXCLAMATION EQ; // '!=';
LSHIFT		: LT LT; 		// '<<';
RSHIFT		: GT GT; 		// '>>';
PLUSEQ		: PLUS EQ; 		// '+=';
MATCH		: EQ TILDE;		// "=~"
NOTMATCH	: EXCLAMATION TILDE; // '!~'
LLCOLLECT  	: LT LT PIPE; 	// '<<|'
LCOLLECT	: LT PIPE; 		// '<|'
INEDGE		: MINUS GT; 	// '->'
OUTEDGE		: LT MINUS; 	// '<-'
INEDGE_SUB	: TILDE GT; 	// '~>'
OUTEDGE_SUB	: LT TILDE; 	// '<~'
RRCOLLECT	: PIPE GT GT ; // '|>>'
RCOLLECT	: PIPE GT; 		// '|>'
FARROW		: EQ GT; 		// '=>'
PARROW		: PLUS GT; 		// '+>'
NS			: COLON COLON; 	// '::'

// Unused in this grammar
// AMPER2		: AMPER AMPER; 	// '&&';
// PIPE2		: PIPE PIPE; 	// '||';
// MINUSEQ		: MINUS EQ; 	// '-=';
// TIMESEQ		: ASTERISK EQ; 	// '*=';
// PERCENTEQ	: PERCENT EQ; 	// '%=';
// LSHIFTEQ		: LT LT EQ; 	// '<<=';
// RSHIFTEQ		: GT GT EQ;		// '>>=';
// AMPEREQ		: AMPER EQ;		// '&=';
// PIPEEQ		: PIPE EQ; 		// '|=';
// CARETEQ		: CARET EQ;		// '^=';
// DIVIDEEQ		: SLASH EQ;		// '/=';
// PLUS2		: PLUS PLUS; //'++';
// MINUS2		: MINUS MINUS; //'--';
// EQ3			: EQ EQ EQ; // '===';
// NOTEQ2		: EXCLAMATION EQ EQ; // '!==';
// GT3			: GT GT GT; // '>>>';
// GT3EQ		: GT GT GT EQ; // '>>>=';


// ML_COMMENT PATTERN: '/' '*' '/'* ( !('*' | '/') | !'*' '/' | '*' !'/')* '*'+ '/';
// Note: accepts '/' '*' '/ 'as multiline comment, don't know if that is valid in puppet.
ML_COMMENT 
	: SLASH ASTERISK SLASH*
	  ( SOURCE_CHARACTER_EXCEPT__ASTERISK_SLASH 
	  | SOURCE_CHARACTER_EXCEPT__ASTERISK  SLASH 
	  | ASTERISK SOURCE_CHARACTER_EXCEPT__SLASH)*
	  ASTERISK+ SLASH
	;

SL_COMMENT 
	: HASH 
		( ANY_DIGIT
		| ANY_LETTER
		| PUNCTUATION
		| SP 
//		| TAB | NBSP // now included in SP
		)*
	  CR? // CR optional depending on file format 	
	  NL // NL optional because file may end with a SL comment, but if made optinal there are conficts.
	 ;

// WHITESPACE
// In this grammar comments, strings, and regexp can not be handled as terminals as the parsing depends
// on context. WS, ML_COMMENT and SL_COMMENT are therefore data rules.
//
OWS 	: WHITE* ;

// Specified to allow a callback to parser to produce an OWS object with an array of WHITE

OWSOBJ 	returns pp::OWS: {pp::OWS} values += WHITE* ;

WHITE 	: ( WSR | ML_COMMENT | SL_COMMENT) ;
WSR		: WS_CHAR+ ;
WS_CHAR : ( SP | CR | NL 
//	| TAB | NBSP // now included in SP
	) ;

// TERMINALS (NO TERMINALS ABOVE THIS POINT)
//

// Note that ML and SL comments can not be terminals - See corresponding data rules ML_COMMENT, SL_COMMENT
//terminal ML_COMMENT : '/*' (!'*') -> '*/' ;
//terminal SL_COMMENT : '#' !('\n'|'\r')* ('\r'? '\n')? ;

terminal LOWER_A : 'a';
terminal LOWER_B : 'b';
terminal LOWER_C : 'c';
terminal LOWER_D : 'd';
terminal LOWER_E : 'e';
terminal LOWER_F : 'f';
terminal LOWER_G : 'g';
terminal LOWER_H : 'h';
terminal LOWER_I : 'i';
terminal LOWER_J : 'j';
terminal LOWER_K : 'k';
terminal LOWER_L : 'l';
terminal LOWER_M : 'm';
terminal LOWER_N : 'n';
terminal LOWER_O : 'o';
terminal LOWER_P : 'p';
terminal LOWER_Q : 'q';
terminal LOWER_R : 'r';
terminal LOWER_S : 's';
terminal LOWER_T : 't';
terminal LOWER_U : 'u';
terminal LOWER_V : 'v';
terminal LOWER_W : 'w';
terminal LOWER_X : 'x';
terminal LOWER_Y : 'y';
terminal LOWER_Z : 'z';

//terminal UPPER_A : 'A';
//terminal UPPER_B : 'B';
//terminal UPPER_C : 'C';
//terminal UPPER_D : 'D';
//terminal UPPER_E : 'E';
//terminal UPPER_F : 'F';
//
//terminal UPPER_M : 'M';
//terminal UPPER_X : 'X';

// All upper chars in one rule (if adding support for Ruby Meta and Control escapes, this must change
terminal UPPER_ALPHA_CHAR 	: ('A'..'Z');
//terminal UPPER_ALPHA_CHAR_EXT 	: ('G'..'L') | ('N'..'W') | 'Y' | 'Z' ;

terminal SP		: (' ' | ' ' | '\t')+ ; // Note that second space is a UNICODE NBSP 
//terminal SP			: ' ';
//terminal NBSP		: ' '; // Note that the space is a UNICODE NBSP

terminal CR			: '\r';
terminal NL			: '\n';
//terminal TAB		: '\t';

terminal EXCLAMATION: '!';
terminal QUOTE		: '"';
terminal HASH		: '#';
terminal DOLLAR		: '$';
terminal PERCENT	: '%';
terminal AMPER		: '&';
terminal APOSTROPHE	: '\'';
terminal LPAREN		: '(';
terminal RPAREN		: ')';
terminal ASTERISK	: '*';
terminal PLUS		: '+';
terminal COMMA		: ',';
terminal MINUS		: '-';
terminal DOT		: '.';
terminal SLASH		: '/';

// Note: see DEC rule
//terminal ZERO 		: '0';
//terminal DIGIT_ONE_TO_SEVEN: ('1'..'7');
//terminal DIGIT_EIGHT_NINE : ('8'..'9');

terminal COLON		: ':';
terminal SEMI		: ';';
terminal LT			: '<';
terminal EQ			: '=';
terminal GT			: '>';
terminal QUESTION	: '?';
terminal AT			: '@';
// A-Z
terminal LBRACK		: '[';
terminal BSLASH		: '\\';
terminal RBRACK		: ']';
terminal CARET		: '^';
terminal UNDERSCORE	: '_';
terminal GRAVE		: '`';
// a-z
terminal LBRACE		: '{';
terminal PIPE		: '|';
terminal RBRACE		: '}';
terminal TILDE		: '~';

terminal UNICODE_LETTER
:  'ª' // uaa
|  'µ' // ub5
|  'º' // uba
|  ('À'..'Ö') // uc0..ud6
|  ('Ø'..'ö') // ud8..uf6
|  ('ø'..'ȟ') // uf8..u21f
|  ('Ȣ'..'ȳ') // u222..u233
|  ('ɐ'..'ʭ') // u250..u2ad
|  ('ʰ'..'ʸ') // u2b0..u2b8
|  ('ʻ'..'ˁ') // u2bb..u2c1
|  ('ː'..'ˑ') // u2d0..u2d1
|  ('ˠ'..'ˤ') // u2e0..u2e4
|  'ˮ' // u2ee
|  'ͺ' // u37a
|  'Ά' // u386
|  ('Έ'..'Ί') // u388..u38a
|  'Ό' // u38c
|  ('Ύ'..'Ρ') // u38e..u3a1
|  ('Σ'..'ώ') // u3a3..u3ce
|  ('ϐ'..'ϗ') // u3d0..u3d7
|  ('Ϛ'..'ϳ') // u3da..u3f3
|  ('Ѐ'..'ҁ') // u400..u481
|  ('Ҍ'..'ӄ') // u48c..u4c4
|  ('Ӈ'..'ӈ') // u4c7..u4c8
|  ('Ӌ'..'ӌ') // u4cb..u4cc
|  ('Ӑ'..'ӵ') // u4d0..u4f5
|  ('Ӹ'..'ӹ') // u4f8..u4f9
|  ('Ա'..'Ֆ') // u531..u556
|  'ՙ' // u559
|  ('ա'..'և') // u561..u587
|  ('א'..'ת') // u5d0..u5ea
|  ('װ'..'ײ') // u5f0..u5f2
|  ('ء'..'غ') // u621..u63a
|  ('ـ'..'ي') // u640..u64a
|  ('ٱ'..'ۓ') // u671..u6d3
|  'ە' // u6d5
|  ('ۥ'..'ۦ') // u6e5..u6e6
|  ('ۺ'..'ۼ') // u6fa..u6fc
|  'ܐ' // u710
|  ('ܒ'..'ܬ') // u712..u72c
|  ('ހ'..'ޥ') // u780..u7a5
|  ('अ'..'ह') // u905..u939
|  'ऽ' // u93d
|  'ॐ' // u950
|  ('क़'..'ॡ') // u958..u961
|  ('অ'..'ঌ') // u985..u98c
|  ('এ'..'ঐ') // u98f..u990
|  ('ও'..'ন') // u993..u9a8
|  ('প'..'র') // u9aa..u9b0
|  'ল' // u9b2
|  ('শ'..'হ') // u9b6..u9b9
|  ('ড়'..'ঢ়') // u9dc..u9dd
|  ('য়'..'ৡ') // u9df..u9e1
|  ('ৰ'..'ৱ') // u9f0..u9f1
|  ('ਅ'..'ਊ') // ua05..ua0a
|  ('ਏ'..'ਐ') // ua0f..ua10
|  ('ਓ'..'ਨ') // ua13..ua28
|  ('ਪ'..'ਰ') // ua2a..ua30
|  ('ਲ'..'ਲ਼') // ua32..ua33
|  ('ਵ'..'ਸ਼') // ua35..ua36
|  ('ਸ'..'ਹ') // ua38..ua39
|  ('ਖ਼'..'ੜ') // ua59..ua5c
|  'ਫ਼' // ua5e
|  ('ੲ'..'ੴ') // ua72..ua74
|  ('અ'..'ઋ') // ua85..ua8b
|  'ઍ' // ua8d
|  ('એ'..'ઑ') // ua8f..ua91
|  ('ઓ'..'ન') // ua93..uaa8
|  ('પ'..'ર') // uaaa..uab0
|  ('લ'..'ળ') // uab2..uab3
|  ('વ'..'હ') // uab5..uab9
|  'ઽ' // uabd
|  'ૐ' // uad0
|  'ૠ' // uae0
|  ('ଅ'..'ଌ') // ub05..ub0c
|  ('ଏ'..'ଐ') // ub0f..ub10
|  ('ଓ'..'ନ') // ub13..ub28
|  ('ପ'..'ର') // ub2a..ub30
|  ('ଲ'..'ଳ') // ub32..ub33
|  ('ଶ'..'ହ') // ub36..ub39
|  'ଽ' // ub3d
|  ('ଡ଼'..'ଢ଼') // ub5c..ub5d
|  ('ୟ'..'ୡ') // ub5f..ub61
|  ('அ'..'ஊ') // ub85..ub8a
|  ('எ'..'ஐ') // ub8e..ub90
|  ('ஒ'..'க') // ub92..ub95
|  ('ங'..'ச') // ub99..ub9a
|  'ஜ' // ub9c
|  ('ஞ'..'ட') // ub9e..ub9f
|  ('ண'..'த') // uba3..uba4
|  ('ந'..'ப') // uba8..ubaa
|  ('ம'..'வ') // ubae..ubb5
|  ('ஷ'..'ஹ') // ubb7..ubb9
|  ('అ'..'ఌ') // uc05..uc0c
|  ('ఎ'..'ఐ') // uc0e..uc10
|  ('ఒ'..'న') // uc12..uc28
|  ('ప'..'ళ') // uc2a..uc33
|  ('వ'..'హ') // uc35..uc39
|  ('ౠ'..'ౡ') // uc60..uc61
|  ('ಅ'..'ಌ') // uc85..uc8c
|  ('ಎ'..'ಐ') // uc8e..uc90
|  ('ಒ'..'ನ') // uc92..uca8
|  ('ಪ'..'ಳ') // ucaa..ucb3
|  ('ವ'..'ಹ') // ucb5..ucb9
|  'ೞ' // ucde
|  ('ೠ'..'ೡ') // uce0..uce1
|  ('അ'..'ഌ') // ud05..ud0c
|  ('എ'..'ഐ') // ud0e..ud10
|  ('ഒ'..'ന') // ud12..ud28
|  ('പ'..'ഹ') // ud2a..ud39
|  ('ൠ'..'ൡ') // ud60..ud61
|  ('අ'..'ඖ') // ud85..ud96
|  ('ක'..'න') // ud9a..udb1
|  ('ඳ'..'ර') // udb3..udbb
|  'ල' // udbd
|  ('ව'..'ෆ') // udc0..udc6
|  ('ก'..'ะ') // ue01..ue30
|  ('า'..'ำ') // ue32..ue33
|  ('เ'..'ๆ') // ue40..ue46
|  ('ກ'..'ຂ') // ue81..ue82
|  'ຄ' // ue84
|  ('ງ'..'ຈ') // ue87..ue88
|  'ຊ' // ue8a
|  'ຍ' // ue8d
|  ('ດ'..'ທ') // ue94..ue97
|  ('ນ'..'ຟ') // ue99..ue9f
|  ('ມ'..'ຣ') // uea1..uea3
|  'ລ' // uea5
|  'ວ' // uea7
|  ('ສ'..'ຫ') // ueaa..ueab
|  ('ອ'..'ະ') // uead..ueb0
|  ('າ'..'ຳ') // ueb2..ueb3
|  ('ຽ'..'ໄ') // uebd..uec4
|  'ໆ' // uec6
|  ('ໜ'..'ໝ') // uedc..uedd
|  'ༀ' // uf00
|  ('ཀ'..'ཪ') // uf40..uf6a
|  ('ྈ'..'ྋ') // uf88..uf8b
|  ('က'..'အ') // u1000..u1021
|  ('ဣ'..'ဧ') // u1023..u1027
|  ('ဩ'..'ဪ') // u1029..u102a
|  ('ၐ'..'ၕ') // u1050..u1055
|  ('Ⴀ'..'Ⴥ') // u10a0..u10c5
|  ('ა'..'ჶ') // u10d0..u10f6
|  ('ᄀ'..'ᅙ') // u1100..u1159
|  ('ᅟ'..'ᆢ') // u115f..u11a2
|  ('ᆨ'..'ᇹ') // u11a8..u11f9
|  ('ሀ'..'ሆ') // u1200..u1206
|  ('ለ'..'ቆ') // u1208..u1246
|  'ቈ' // u1248
|  ('ቊ'..'ቍ') // u124a..u124d
|  ('ቐ'..'ቖ') // u1250..u1256
|  'ቘ' // u1258
|  ('ቚ'..'ቝ') // u125a..u125d
|  ('በ'..'ኆ') // u1260..u1286
|  'ኈ' // u1288
|  ('ኊ'..'ኍ') // u128a..u128d
|  ('ነ'..'ኮ') // u1290..u12ae
|  'ኰ' // u12b0
|  ('ኲ'..'ኵ') // u12b2..u12b5
|  ('ኸ'..'ኾ') // u12b8..u12be
|  'ዀ' // u12c0
|  ('ዂ'..'ዅ') // u12c2..u12c5
|  ('ወ'..'ዎ') // u12c8..u12ce
|  ('ዐ'..'ዖ') // u12d0..u12d6
|  ('ዘ'..'ዮ') // u12d8..u12ee
|  ('ደ'..'ጎ') // u12f0..u130e
|  'ጐ' // u1310
|  ('ጒ'..'ጕ') // u1312..u1315
|  ('ጘ'..'ጞ') // u1318..u131e
|  ('ጠ'..'ፆ') // u1320..u1346
|  ('ፈ'..'ፚ') // u1348..u135a
|  ('Ꭰ'..'Ꮀ') // u13a0..u13b0
|  ('Ꮁ'..'Ᏼ') // u13b1..u13f4
|  ('ᐁ'..'ᙶ') // u1401..u1676
|  ('ᚁ'..'ᚚ') // u1681..u169a
|  ('ᚠ'..'ᛪ') // u16a0..u16ea
|  ('ក'..'ឳ') // u1780..u17b3
|  ('ᠠ'..'ᡷ') // u1820..u1877
|  ('ᢀ'..'ᢨ') // u1880..u18a8
|  ('Ḁ'..'ẛ') // u1e00..u1e9b
|  ('Ạ'..'Ỡ') // u1ea0..u1ee0
|  ('ỡ'..'ỹ') // u1ee1..u1ef9
|  ('ἀ'..'ἕ') // u1f00..u1f15
|  ('Ἐ'..'Ἕ') // u1f18..u1f1d
|  ('ἠ'..'Ἱ') // u1f20..u1f39
|  ('Ἲ'..'ὅ') // u1f3a..u1f45
|  ('Ὀ'..'Ὅ') // u1f48..u1f4d
|  ('ὐ'..'ὗ') // u1f50..u1f57
|  'Ὑ' // u1f59
|  'Ὓ' // u1f5b
|  'Ὕ' // u1f5d
|  ('Ὗ'..'ώ') // u1f5f..u1f7d
|  ('ᾀ'..'ᾴ') // u1f80..u1fb4
|  ('ᾶ'..'ᾼ') // u1fb6..u1fbc
|  'ι' // u1fbe
|  ('ῂ'..'ῄ') // u1fc2..u1fc4
|  ('ῆ'..'ῌ') // u1fc6..u1fcc
|  ('ῐ'..'ΐ') // u1fd0..u1fd3
|  ('ῖ'..'Ί') // u1fd6..u1fdb
|  ('ῠ'..'Ῥ') // u1fe0..u1fec
|  ('ῲ'..'ῴ') // u1ff2..u1ff4
|  ('ῶ'..'ῼ') // u1ff6..u1ffc
|  'ⁿ' // u207f
|  'ℂ' // u2102
|  'ℇ' // u2107
|  ('ℊ'..'ℓ') // u210a..u2113
|  'ℕ' // u2115
|  ('ℙ'..'ℝ') // u2119..u211d
|  'ℤ' // u2124
|  'Ω' // u2126
|  'ℨ' // u2128
|  ('K'..'ℭ') // u212a..u212d
|  ('ℯ'..'ℱ') // u212f..u2131
|  ('ℳ'..'ℹ') // u2133..u2139
|  ('Ⅰ'..'Ↄ') // u2160..u2183
|  ('々'..'〇') // u3005..u3007
|  ('〡'..'〩') // u3021..u3029
|  ('〱'..'〵') // u3031..u3035
|  ('〸'..'〺') // u3038..u303a
|  ('ぁ'..'ゔ') // u3041..u3094
|  ('ゝ'..'ゞ') // u309d..u309e
|  ('ァ'..'ヺ') // u30a1..u30fa
|  ('ー'..'ヾ') // u30fc..u30fe
|  ('ㄅ'..'ㄬ') // u3105..u312c
|  ('ㄱ'..'ㆎ') // u3131..u318e
|  ('ㆠ'..'ㆷ') // u31a0..u31b7
|  '㐀' // u3400
|  '䶵' // u4db5
|  '一' // u4e00
|  '龥' // u9fa5
|  ('ꀀ'..'ꒌ') // ua000..ua48c
|  '가' // uac00
|  '힣' // ud7a3
|  ('豈'..'鶴') // uf900..ufa2d
|  ('ﬀ'..'ﬆ') // ufb00..ufb06
|  ('ﬓ'..'ﬗ') // ufb13..ufb17
|  'יִ' // ufb1d
|  ('ײַ'..'ﬨ') // ufb1f..ufb28
|  ('שׁ'..'זּ') // ufb2a..ufb36
|  ('טּ'..'לּ') // ufb38..ufb3c
|  'מּ' // ufb3e
|  ('נּ'..'סּ') // ufb40..ufb41
|  ('ףּ'..'פּ') // ufb43..ufb44
|  ('צּ'..'ﮱ') // ufb46..ufbb1
|  ('ﯓ'..'ﴽ') // ufbd3..ufd3d
|  ('ﵐ'..'ﶏ') // ufd50..ufd8f
|  ('ﶒ'..'ﷇ') // ufd92..ufdc7
|  ('ﷰ'..'ﷻ') // ufdf0..ufdfb
|  ('ﹰ'..'ﹲ') // ufe70..ufe72
|  'ﹴ' // ufe74
|  ('ﹶ'..'ﻼ') // ufe76..ufefc
|  ('Ａ'..'Ｚ') // uff21..uff3a
|  ('ａ'..'ｚ') // uff41..uff5a
|  ('ｦ'..'ﾾ') // uff66..uffbe
|  ('ￂ'..'ￇ') // uffc2..uffc7
|  ('ￊ'..'ￏ') // uffca..uffcf
|  ('ￒ'..'ￗ') // uffd2..uffd7
|  ('ￚ'..'ￜ') // uffda..uffdc
;
terminal UNICODE_DIGIT
:  ('٠'..'٩') // u660..u669
|  ('۰'..'۹') // u6f0..u6f9
|  ('०'..'९') // u966..u96f
|  ('০'..'৯') // u9e6..u9ef
|  ('੦'..'੯') // ua66..ua6f
|  ('૦'..'૯') // uae6..uaef
|  ('୦'..'୯') // ub66..ub6f
|  ('௧'..'௯') // ube7..ubef
|  ('౦'..'౯') // uc66..uc6f
|  ('೦'..'೯') // uce6..ucef
|  ('൦'..'൯') // ud66..ud6f
|  ('๐'..'๙') // ue50..ue59
|  ('໐'..'໙') // ued0..ued9
|  ('༠'..'༩') // uf20..uf29
|  ('၀'..'၉') // u1040..u1049
|  ('፩'..'፱') // u1369..u1371
|  ('០'..'៩') // u17e0..u17e9
|  ('᠐'..'᠙') // u1810..u1819
|  ('０'..'９') // uff10..uff19
;

terminal UNICODE_NONSPACING_MARK
:  ('̀'..'ͯ') // u300..u36f
;
terminal UNICODE_COMBINING_MARK
:  ('̀'..'͎') // u300..u34e
|  ('͠'..'͢') // u360..u362
|  ('҃'..'҆') // u483..u486
|  ('֑'..'֡') // u591..u5a1
|  ('֣'..'ֹ') // u5a3..u5b9
|  ('ֻ'..'ֽ') // u5bb..u5bd
|  'ֿ' // u5bf
|  ('ׁ'..'ׂ') // u5c1..u5c2
|  'ׄ' // u5c4
|  ('ً'..'ٕ') // u64b..u655
|  'ٰ' // u670
|  ('ۖ'..'ۜ') // u6d6..u6dc
|  ('۟'..'ۤ') // u6df..u6e4
|  ('ۧ'..'ۨ') // u6e7..u6e8
|  ('۪'..'ۭ') // u6ea..u6ed
|  'ܑ' // u711
|  ('ܰ'..'݊') // u730..u74a
|  ('ަ'..'ް') // u7a6..u7b0
|  ('ँ'..'ः') // u901..u903
|  '़' // u93c
|  ('ा'..'्') // u93e..u94d
|  ('॑'..'॔') // u951..u954
|  ('ॢ'..'ॣ') // u962..u963
|  ('ঁ'..'ঃ') // u981..u983
|  ('়'..'ৄ') // u9bc..u9c4
|  ('ে'..'ৈ') // u9c7..u9c8
|  ('ো'..'্') // u9cb..u9cd
|  'ৗ' // u9d7
|  ('ৢ'..'ৣ') // u9e2..u9e3
|  'ਂ' // ua02
|  '਼' // ua3c
|  ('ਾ'..'ੂ') // ua3e..ua42
|  ('ੇ'..'ੈ') // ua47..ua48
|  ('ੋ'..'੍') // ua4b..ua4d
|  ('ੰ'..'ੱ') // ua70..ua71
|  ('ઁ'..'ઃ') // ua81..ua83
|  '઼' // uabc
|  ('ા'..'ૅ') // uabe..uac5
|  ('ે'..'ૉ') // uac7..uac9
|  ('ો'..'્') // uacb..uacd
|  ('ଁ'..'ଃ') // ub01..ub03
|  '଼' // ub3c
|  ('ା'..'ୃ') // ub3e..ub43
|  ('େ'..'ୈ') // ub47..ub48
|  ('ୋ'..'୍') // ub4b..ub4d
|  ('ୖ'..'ୗ') // ub56..ub57
|  ('ஂ'..'ஃ') // ub82..ub83
|  ('ா'..'ூ') // ubbe..ubc2
|  ('ெ'..'ை') // ubc6..ubc8
|  ('ொ'..'்') // ubca..ubcd
|  'ௗ' // ubd7
|  ('ఁ'..'ః') // uc01..uc03
|  ('ా'..'ౄ') // uc3e..uc44
|  ('ె'..'ై') // uc46..uc48
|  ('ొ'..'్') // uc4a..uc4d
|  ('ౕ'..'ౖ') // uc55..uc56
|  ('ಂ'..'ಃ') // uc82..uc83
|  ('ಾ'..'ೄ') // ucbe..ucc4
|  ('ೆ'..'ೈ') // ucc6..ucc8
|  ('ೊ'..'್') // ucca..uccd
|  ('ೕ'..'ೖ') // ucd5..ucd6
|  ('ം'..'ഃ') // ud02..ud03
|  ('ാ'..'ൃ') // ud3e..ud43
|  ('െ'..'ൈ') // ud46..ud48
|  ('ൊ'..'്') // ud4a..ud4d
|  'ൗ' // ud57
|  ('ං'..'ඃ') // ud82..ud83
|  '්' // udca
|  ('ා'..'ු') // udcf..udd4
|  'ූ' // udd6
|  ('ෘ'..'ෟ') // udd8..uddf
|  ('ෲ'..'ෳ') // udf2..udf3
|  'ั' // ue31
|  ('ิ'..'ฺ') // ue34..ue3a
|  ('็'..'๎') // ue47..ue4e
|  'ັ' // ueb1
|  ('ິ'..'ູ') // ueb4..ueb9
|  ('ົ'..'ຼ') // uebb..uebc
|  ('່'..'ໍ') // uec8..uecd
|  ('༘'..'༙') // uf18..uf19
|  '༵' // uf35
|  '༷' // uf37
|  '༹' // uf39
|  ('༾'..'༿') // uf3e..uf3f
|  ('ཱ'..'྄') // uf71..uf84
|  ('྆'..'྇') // uf86..uf87
|  ('ྐ'..'ྗ') // uf90..uf97
|  ('ྙ'..'ྼ') // uf99..ufbc
|  '࿆' // ufc6
|  ('ာ'..'ဲ') // u102c..u1032
|  ('ံ'..'္') // u1036..u1039
|  ('ၖ'..'ၙ') // u1056..u1059
|  ('឴'..'៓') // u17b4..u17d3
|  'ᢩ' // u18a9
|  ('⃐'..'⃜') // u20d0..u20dc
|  '⃡' // u20e1
|  ('〪'..'〯') // u302a..u302f
|  ('゙'..'゚') // u3099..u309a
|  'ﬞ' // ufb1e
|  ('︠'..'︣') // ufe20..ufe23
;
terminal UNICODE_CONNECTOR_PUNCTUATION
:  '_' // u5f
|  ('‿'..'⁀') // u203f..u2040
|  '・' // u30fb
|  ('︳'..'︴') // ufe33..ufe34
|  ('﹍'..'﹏') // ufe4d..ufe4f
|  '＿' // uff3f
|  '･' // uff65
;
terminal USP: ' '  // OGHAM SPACE MARK
| ' '  // EN QUAD
| ' '  // EM QUAD
| ' '  // EN SPACE
| ' '  // EM SPACE
| ' '  // THREE-PER-EM SPACE
| ' '  // FOUR-PER-EM SPACE
| ' '  // SIX-PER-EM SPACE
| ' '  // FIGURE SPACE
| ' '  // PUNCTUATION SPACE
| ' '  // THIN SPACE
| ' '  // HAIR SPACE
| '​'  // ZERO WIDTH SPACE
| ' '  // NARROW NO-BREAK SPACE
| '　'  // IDEOGRAPHIC SPACE
;
